---
title: GooGuns
date: 2016-10-09 10:36:00 -0700
mdate: 2017-03-10 19:48:00 -0700
# extra_css: bots_googuns
extra_js: bots_googuns
---
<style>
td {
  max-width: 100px;
  overflow-wrap: break-word;
}
</style>

<div class="row">
  <div class="col-sm-6 col-md-3 col-lg-2">
    <p>@googuns_lulz was inspired by other <code>@googuns_</code> Twitter bots.</p>

    <p>Some parts of its messages are random, but some are defined.</p>
  </div>
  <div class="col-sm-6 col-md-4 col-lg-4">
    <a class="twitter-timeline" data-height="300" data-chrome="nofooter" data-dnt="true" href="https://twitter.com/googuns_lulz">Tweets by @googuns_lulz</a>
    <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
  <div class="col-12 col-md-5 col-lg-6">
    <h2>Message Parser</h2>

    <p>Copy and paste a tweet:</p>

    <textarea class="form-control" id="msg" maxlength="280" placeholder="0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"></textarea>
  </div>
</div>

<h2>v2.0 Format <span id="f2_valid" class="badge badge-success d-none">Valid</span></h2>
<p>
  128 bytes (91.4% of all 140 bytes) contain information (are not red/green in the table).
  v2.0 was released <a href="https://twitter.com/googuns_lulz/status/938952772610904069"><span class="timeago" title="2017-12-07T19:06:00-07:00">near the end of 2017</span></a>.
</p>
<table class="table table-bordered table-hover">
  <thead>
    <tr>
      <th colspan="2">Offset</th>
      <th colspan="2">Length</th>
      <th>Description</th>
      <th>Entered</th>
    </tr>
  </thead>
  <tr>
    <td>0x00</td>
    <td>0</td>
    <td>0x8</td>
    <td>8</td>
    <td>64-bit UNIX timestamp ^ data[61:69]</td>
    <td id="f2_0"></td>
  </tr>
  <tr>
    <td>0x08</td>
    <td>8</td>
    <td>0x1</td>
    <td>1</td>
    <td>version (0x20)</td>
    <td id="f2_1"></td>
  </tr>
  <tr>
    <td>0x09</td>
    <td>9</td>
    <td>0x37</td>
    <td>55</td>
    <td>undefined</td>
    <td id="f2_2"></td>
  </tr>
  <tr>
    <td>0x40</td>
    <td>64</td>
    <td>0x08</td>
    <td>8</td>
    <td>checksum</td>
    <td id="f2_3"></td>
  </tr>
  <tr>
    <td>0x48</td>
    <td>72</td>
    <td>0x41</td>
    <td>65</td>
    <td>undefined</td>
    <td id="f2_4"></td>
  </tr>
  <tr>
    <td>0x89</td>
    <td>137</td>
    <td>0x3</td>
    <td>3</td>
    <td>zero (0x000000)</td>
    <td id="f2_5"></td>
  </tr>
</table>

<table class="table table-bordered table-hover">
  <thead>
    <tr>
      <th>Derived</th>
      <th colspan="2">Value</th>
    </tr>
  </thead>
  <tr>
    <td>UNIX timestamp</td>
    <td id="d2_time"></td>
    <td id="d2_time_parsed"></td>
  </tr>
  <tr>
    <td>checksum</td>
    <td id="d2_c0" colspan="2"></td>
  </tr>
</table>

<p>The checksum is such that the XOR of the 64-bit words (18 in total) of <code>data + data[136:]</code> is zero.</p>
<p>
  checksum =
  <code>
    data[:8] ^ data[8:16] ^ data[8:16] ^ data[16:24] ^
    data[24:32] ^ data[32:40] ^ data[40:48] ^ data[48:56] ^
    data[56:64] ^ 0 ^ data[72:80] ^ data[80:88] ^
    data[88:96] ^ data[96:104] ^ data[104:112] ^ data[112:120] ^
    data[120:128] ^ data[128:136] ^ ((data[136:] &lt;&lt; 32) ^ data[136:])
  </code>
</p>

<h2>v1.1 Format <span id="f1.1_valid" class="badge badge-success d-none">Valid</span></h2>
<p>
  64 bytes (91.4% of all 70 bytes) contain information (are not red/green in the table).
  v1.1 was released <span class="timeago" title="2017-03-10T19:48:00-07:00">in Mar 2017</span>.
</p>
<p>
  All valid messages in v1.1 or v1 Format are guaranteed to be invalid in the other.
  Compared to v1, v1.1 has less redundancy.
</p>
<table class="table table-bordered table-hover">
  <thead>
    <tr>
      <th colspan="2">Offset</th>
      <th colspan="2">Length</th>
      <th>Description</th>
      <th>Entered</th>
    </tr>
  </thead>
  <tr>
    <td>0x00</td>
    <td>0</td>
    <td>0x8</td>
    <td>8</td>
    <td>64-bit UNIX timestamp ^ data[9:17] ^ data[32:40]</td>
    <td id="f1.1_0"></td>
  </tr>
  <tr>
    <td>0x08</td>
    <td>8</td>
    <td>0x1</td>
    <td>1</td>
    <td>~hash1[0]</td>
    <td id="f1.1_1"></td>
  </tr>
  <tr>
    <td>0x09</td>
    <td>9</td>
    <td>0x1</td>
    <td>1</td>
    <td>hash0[1]</td>
    <td id="f1.1_2"></td>
  </tr>
  <tr>
    <td>0x0A</td>
    <td>10</td>
    <td>0x34</td>
    <td>52</td>
    <td>undefined</td>
    <td id="f1.1_3"></td>
  </tr>
  <tr>
    <td>0x3E</td>
    <td>62</td>
    <td>0x1</td>
    <td>1</td>
    <td>version (0x01)</td>
    <td id="f1.1_4"></td>
  </tr>
  <tr>
    <td>0x3F</td>
    <td>63</td>
    <td>0x4</td>
    <td>4</td>
    <td>undefined</td>
    <td id="f1.1_5"></td>
  </tr>
  <tr>
    <td>0x43</td>
    <td>67</td>
    <td>0x3</td>
    <td>3</td>
    <td>zero (0x000000)</td>
    <td id="f1.1_6"></td>
  </tr>
</table>

<table class="table table-bordered table-hover">
  <thead>
    <tr>
      <th>Derived</th>
      <th colspan="2">Value</th>
    </tr>
  </thead>
  <tr>
    <td>UNIX timestamp</td>
    <td id="d1.1_time"></td>
    <td id="d1.1_time_parsed"></td>
  </tr>
  <tr>
    <td>hash0 = sha256(data[10:])</td>
    <td id="d1.1_c0" colspan="2"></td>
  </tr>
  <tr>
    <td>hash1 = sha1(data[:8])</td>
    <td id="d1.1_c1" colspan="2"></td>
  </tr>
</table>

<h2>v1 Format <span id="f1_valid" class="badge badge-success d-none">Valid</span></h2>
<p>
  24 bytes (34.3% of all 70 bytes) contain information.
  v1 was released <span class="timeago" title="2016-10-09T11:36:00-06:00">in Oct 2016</span>.
</p>
<table class="table table-bordered table-hover">
  <thead>
    <tr>
      <th colspan="2">Offset</th>
      <th colspan="2">Length</th>
      <th>Description</th>
      <th>Entered</th>
    </tr>
  </thead>
  <tr>
    <td>0x00</td>
    <td>0</td>
    <td>0x8</td>
    <td>8</td>
    <td>transformed 64-bit timestamp*</td>
    <td id="f1_0"></td>
  </tr>
  <tr>
    <td>0x08</td>
    <td>8</td>
    <td>0xC</td>
    <td>10</td>
    <td>hash1[:10]</td>
    <td id="f1_1"></td>
  </tr>
  <tr>
    <td>0x12</td>
    <td>18</td>
    <td>0xC</td>
    <td>10</td>
    <td>hash1[:10] xor (A+B+C)**</td>
    <td id="f1_2"></td>
  </tr>
  <tr>
    <td>0x1C</td>
    <td>28</td>
    <td>0x2</td>
    <td>2</td>
    <td>undefined</td>
    <td id="f1_3"></td>
  </tr>
  <tr>
    <td>0x1E</td>
    <td>30</td>
    <td>0x20</td>
    <td>32</td>
    <td>hash2</td>
    <td id="f1_4"></td>
  </tr>
  <tr>
    <td>0x3E</td>
    <td>62</td>
    <td>0x1</td>
    <td>1</td>
    <td>version (0x01)</td>
    <td id="f1_5"></td>
  </tr>
  <tr>
    <td>0x3F</td>
    <td>63</td>
    <td>0x4</td>
    <td>4</td>
    <td>undefined</td>
    <td id="f1_6"></td>
  </tr>
  <tr>
    <td>0x43</td>
    <td>67</td>
    <td>0x3</td>
    <td>3</td>
    <td>zero (0x000000)</td>
    <td id="f1_7"></td>
  </tr>
</table>

<table class="table table-bordered table-hover">
  <thead>
    <tr>
      <th>Derived</th>
      <th colspan="2">Value</th>
    </tr>
  </thead>
  <tr>
    <td>hash1 = sha1(data[:8])</td>
    <td id="d1_c1" colspan="2"></td>
  </tr>
  <tr>
    <td>hash2 = sha256(data[:30] + data[62:])</td>
    <td id="d1_c2" colspan="2"></td>
  </tr>
  <tr>
    <td>A + B + C</td>
    <td id="d1_abc" colspan="2"></td>
  </tr>
  <tr>
    <td>UNIX timestamp</td>
    <td id="d1_time"></td>
    <td id="d1_time_parsed"></td>
  </tr>
</table>

<pre class="card card-body bg-light">
* transformed 64-bit timestamp = (([UNIX timestamp] &lt;&lt;&lt; A) ^ B ^ 0x420B16B00B5F1337) &gt;&gt;&gt; C
 A: 1 random byte
 B: 8 random bytes
 C: 1 random byte

 constant explanation:
  42 - reference to The Hitchhiker's Guide to the Galaxy by Douglas Adams
  0 - first separator
  0xB16B00B5 - reference to Microsoft and Linux
  F - last separator
  1337 - exercise for the reader
** originally supposed to be `hash1[10:] xor (A+B+C)`
</pre>

<h1>Notation</h1>
<pre class="card card-body bg-light">
All fields are big endian.
&lt;&lt;&lt; = rol and &gt;&gt;&gt; = ror (bitwise rotations).
^ = bitwise XOR (exclusive OR).
~ = bitwise negation.
+ = concatenation.
data[a:b] = slice from data[a] to data[b-1], with a=0 and b=data.length by default; empty slice if a=b.
</pre>
